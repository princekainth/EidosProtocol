#!/bin/bash

# --- Configuration ---
# Define the project directory relative to the script's location
# This ensures the script works regardless of where it's launched from.
PROJECT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
# Use 'python' executable from the activated virtual environment, not 'python3'
# This is crucial for consistent virtual environment usage.
PYTHON_EXEC="python"
# Port for Ollama server
OLLAMA_PORT="11434"

# --- Directory Setup ---
echo "Ensuring necessary directories exist..."
# Create logs and persistence_data directories if they don't exist
mkdir -p "$PROJECT_DIR/logs"
mkdir -p "$PROJECT_DIR/persistence_data"
echo "Directories ensured."

# --- Clear Persistence Data ---
# Clear previous console log for a fresh start.
# This ensures that a new run doesn't just append to old logs if you're reviewing 'cat console.log'.
# If you want to retain logs across runs, comment this out.
echo "Clearing old log files..."
rm -f "$PROJECT_DIR/logs/*.log"
# Clear persistence data for a clean run of the Eidos OS itself.
# This ensures your agents/swarms start fresh each time you launch the OS.
echo "Clearing persistence data..."
rm -f "$PROJECT_DIR/persistence_data/*.json" "$PROJECT_DIR/persistence_data/*.jsonl"
echo "Persistence data cleared."

# --- Function to Start a Service in a New Terminal Window ---
# Arguments: service_name, command_to_execute, log_file (optional, if omitted, output goes to terminal)
start_service_in_new_terminal() {
    local service_name=$1
    local command_to_execute=$2
    local log_file=$3 # Optional: if provided, output redirects here

    local redirect_output=""
    if [ -n "$log_file" ]; then # If log_file is provided, redirect output
        redirect_output="> \"$log_file\" 2>&1"
    fi

    echo "Attempting to start '$service_name' in a new terminal..."

    # Use a common terminal launcher like 'x-terminal-emulator' or specify 'gnome-terminal' for GNOME.
    # We use 'bash -c' to ensure all commands run in a single shell within the new terminal.
    # The 'exec bash' keeps the terminal window open after the command finishes.

    # macOS specific command
    if [[ "$OSTYPE" == "darwin"* ]]; then
        osascript -e 'tell application "Terminal" to do script "cd \"'$PROJECT_DIR'\" && source venv/bin/activate && '$command_to_execute' '$redirect_output' ; exec bash"'
    # Linux (GNOME specific, using gnome-terminal)
    elif command -v gnome-terminal &> /dev/null; then
        gnome-terminal -- bash -c "cd \"$PROJECT_DIR\" && source venv/bin/activate && $command_to_execute $redirect_output ; exec bash" &
    # Linux (generic, try x-terminal-emulator)
    elif command -v x-terminal-emulator &> /dev/null; then
        x-terminal-emulator -- bash -c "cd \"$PROJECT_DIR\" && source venv/bin/activate && $command_to_execute $redirect_output ; exec bash" &
    else
        echo "Unsupported or unrecognized OS/Terminal: $OSTYPE. Please start '$service_name' manually."
        return 1
    fi
    echo "'$service_name' terminal launch command issued."
}

# --- Start Services ---

# 1. Start Ollama Server (Only if not already running)
echo "Checking Ollama server status..."
# 'nc -z' checks if a port is open. If it's not open (connection refused), try to start Ollama.
# If it's already open, it means Ollama is likely running.
if ! nc -z 127.0.0.1 "$OLLAMA_PORT"; then
  echo "Ollama server not detected. Starting Ollama server..."
  # Redirect Ollama's server output to a dedicated log file to keep console.log clean
  # And run in background using '&'.
  ollama serve > "$PROJECT_DIR/logs/ollama_server.log" 2>&1 &
  # Give Ollama a moment to fully initialize before Python scripts try to connect
  sleep 5
else
  echo "Ollama server already running on port $OLLAMA_PORT."
fi

# 2. Catalyst Vector Alpha (Main Orchestrator)
# This will run the core Eidos Protocol, its output goes to catalyst_alpha.log
echo "Starting Catalyst Vector Alpha..."
# The '-u' flag makes Python output unbuffered, useful when redirecting to logs.
# This is the main process, running in the background.
start_service_in_new_terminal "Catalyst Vector Alpha" "$PYTHON_EXEC -u catalyst_vector_alpha.py" "$PROJECT_DIR/logs/catalyst_alpha.log"
sleep 2 # Give Catalyst Alpha a moment to start processing.

# 3. Swarm Monitor (Real-time activity log viewer)
# This will tail the central swarm_activity.jsonl generated by Catalyst Alpha.
# Its output should primarily be the real-time activity stream.
# We explicitly call 'tail -f' here to have the monitor function in its own terminal.
# The 'exec bash' in start_service_in_new_terminal keeps the terminal open after tailing.
echo "Starting Swarm Monitor..."
start_service_in_new_terminal "Swarm Monitor" "tail -f \"$PROJECT_DIR/persistence_data/swarm_activity.jsonl\"" "$PROJECT_DIR/logs/swarm_monitor.log"
sleep 2 # Small delay

# 4. Swarm Console (Interactive) - This should be truly interactive in its own terminal
# Its output is NOT redirected to a log file, so you can interact with it directly.
echo "Starting Swarm Console..."
start_service_in_new_terminal "Swarm Console (Interactive)" "$PYTHON_EXEC -u swarm_console.py"
sleep 2 # Small delay

# 5. Dashboard (if semantic_dashboard.py exists, assumes it's a Streamlit app)
# Streamlit apps are interactive web apps, they usually run in background and open a browser.
if [ -f "$PROJECT_DIR/semantic_dashboard.py" ]; then
    echo "Starting Dashboard..."
    # Streamlit typically launches a browser. Redirect its console output.
    start_service_in_new_terminal "Dashboard" "streamlit run \"$PROJECT_DIR/semantic_dashboard.py\"" "$PROJECT_DIR/logs/dashboard.log"
    sleep 2
else
    echo "Dashboard (semantic_dashboard.py) not found, skipping launch."
fi

echo "All primary Eidos Protocol System services launched. Check their respective terminals."
echo "Use 'tail -f logs/catalyst_alpha.log' to see the main system's detailed output."
echo "Use 'tail -f logs/swarm_monitor.log' to see the real-time activity blackbox."
echo "Interact with 'Swarm Console (Interactive)' directly in its terminal."

# Prevent the main script from exiting immediately, allowing background processes to run.
# You can remove this line if you prefer the script to exit once all services are launched.
# However, if you want the main script to control the lifecycle (e.g., stopping them later),
# you'd keep it running and handle cleanup.
# For simplicity, if launched with '&' in start_service_in_new_terminal,
# the main script can just exit and leave background processes running.
# Removing the 'read' command makes the script simply launch and exit.
# You can use 'jobs' and 'kill' manually or build a 'stop_os.sh' script.

# Trap to kill background processes if this script is manually terminated (e.g., Ctrl+C)
# Note: This traps signals to the current script, not necessarily to the new terminal processes.
# For robust process management, consider a dedicated process manager like 'systemd' or 'supervisord'.
# For simple shell scripts, users might need to manually kill the terminal windows or processes.
# trap "echo 'Stopping Eidos Protocol services...'; kill \$(jobs -p); exit" INT TERM EXIT